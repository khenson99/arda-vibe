/**
 * Automation Action Handlers
 *
 * Per-action handler functions for the TCAAF pipeline. Each handler
 * delegates to existing service modules for actual business logic,
 * keeping this layer focused on orchestration concerns.
 *
 * The `dispatchAction` switch dispatches to the correct handler
 * based on the ActionType discriminant.
 */

import { db, schema, writeAuditEntry } from '@arda/db';
import { eq, and } from 'drizzle-orm';
import { getEventBus } from '@arda/events';
import { config, createLogger } from '@arda/config';
import { createWorkOrderFromTrigger } from '../work-order-orchestration.service.js';
import { processExceptionAutomation } from '../exception-automation.service.js';
import { autoCreateTransferOrder } from '../kanban-transfer-automation.service.js';
import type {
  ActionType,
  PurchaseOrderContext,
  WorkOrderContext,
  TransferOrderContext,
  EmailDispatchContext,
  CardTransitionContext,
  ExceptionResolutionContext,
} from './types.js';

const log = createLogger('automation:action-handlers');

const {
  purchaseOrders,
  purchaseOrderLines,
  kanbanCards,
} = schema;

// ─── Handler Result ──────────────────────────────────────────────────

export interface ActionHandlerResult {
  success: boolean;
  data?: Record<string, unknown>;
  error?: string;
}

// ─── Dispatch ────────────────────────────────────────────────────────

/**
 * Dispatch an action to its appropriate handler.
 *
 * @param actionType - The type of action to execute
 * @param params - Action-specific parameters
 * @returns Handler result with success flag and optional data
 */
export async function dispatchAction(
  actionType: ActionType,
  params: Record<string, unknown>,
): Promise<ActionHandlerResult> {
  log.info({ actionType }, 'Dispatching action');

  switch (actionType) {
    case 'create_purchase_order':
      return handleCreatePurchaseOrder(params as unknown as PurchaseOrderContext);

    case 'create_work_order':
      return handleCreateWorkOrder(params as unknown as WorkOrderContext);

    case 'create_transfer_order':
      return handleCreateTransferOrder(params as unknown as TransferOrderContext);

    case 'dispatch_email':
      return handleDispatchEmail(params as unknown as EmailDispatchContext);

    case 'add_to_shopping_list':
      return handleAddToShoppingList(params);

    case 'transition_card':
      return handleTransitionCard(params as unknown as CardTransitionContext);

    case 'resolve_exception':
      return handleResolveException(params as unknown as ExceptionResolutionContext);

    case 'escalate':
      return handleEscalate(params);

    default: {
      const _exhaustive: never = actionType;
      return { success: false, error: `Unknown action type: ${_exhaustive}` };
    }
  }
}

// ─── Individual Handlers ─────────────────────────────────────────────

/**
 * Create a draft purchase order from automation context.
 *
 * Inserts a PO record with 'draft' status and creates the associated
 * PO line. Emits a po.created event.
 */
async function handleCreatePurchaseOrder(
  ctx: PurchaseOrderContext,
): Promise<ActionHandlerResult> {
  try {
    const result = await db.transaction(async (tx) => {
      // Generate next PO number
      const poNumber = `PO-AUTO-${Date.now().toString(36).toUpperCase()}`;

      const [po] = await tx
        .insert(purchaseOrders)
        .values({
          tenantId: ctx.tenantId,
          poNumber,
          supplierId: ctx.supplierId,
          facilityId: ctx.facilityId,
          status: 'draft',
          totalAmount: String(ctx.totalAmount ?? 0),
          currency: 'USD',
          orderDate: new Date(),
          internalNotes: `Auto-generated by automation${ctx.isExpedited ? ' (expedited)' : ''}`,
        })
        .returning({ id: purchaseOrders.id, poNumber: purchaseOrders.poNumber })
        .execute();

      // Create the PO line
      await tx
        .insert(purchaseOrderLines)
        .values({
          tenantId: ctx.tenantId,
          purchaseOrderId: po.id,
          partId: ctx.partId,
          lineNumber: 1,
          kanbanCardId: ctx.cardId,
          quantityOrdered: ctx.orderQuantity,
          unitCost: String((ctx.totalAmount ?? 0) / ctx.orderQuantity),
          lineTotal: String(ctx.totalAmount ?? 0),
        })
        .execute();

      // Audit log — system-initiated automation action
      await writeAuditEntry(tx, {
        tenantId: ctx.tenantId,
        userId: null,
        action: 'automation.rule_executed',
        entityType: 'purchase_order',
        entityId: po.id,
        previousState: null,
        newState: {
          poNumber: po.poNumber,
          supplierId: ctx.supplierId,
          amount: ctx.totalAmount,
        },
        metadata: {
          systemActor: 'automation_orchestrator',
          source: 'automation',
        },
      });

      return po;
    });

    // Emit event
    const eventBus = getEventBus(config.REDIS_URL);
    await eventBus.publish({
      type: 'automation.po_created',
      tenantId: ctx.tenantId,
      purchaseOrderId: result.id,
      poNumber: result.poNumber,
      source: 'automation',
      timestamp: new Date().toISOString(),
    });

    log.info(
      { poId: result.id, poNumber: result.poNumber },
      'Purchase order created by automation',
    );

    return {
      success: true,
      data: { purchaseOrderId: result.id, poNumber: result.poNumber },
    };
  } catch (err) {
    log.error({ err, ctx }, 'Failed to create purchase order');
    return {
      success: false,
      error: err instanceof Error ? err.message : String(err),
    };
  }
}

/**
 * Create a work order by delegating to the existing WO orchestration service.
 */
async function handleCreateWorkOrder(
  ctx: WorkOrderContext,
): Promise<ActionHandlerResult> {
  try {
    const result = await createWorkOrderFromTrigger({
      tenantId: ctx.tenantId,
      cardId: ctx.cardId,
      loopId: ctx.loopId,
      partId: ctx.partId,
      facilityId: ctx.facilityId,
      quantity: ctx.orderQuantity,
    });

    log.info(
      { woId: result.workOrderId, woNumber: result.woNumber },
      'Work order created by automation',
    );

    return {
      success: true,
      data: {
        workOrderId: result.workOrderId,
        woNumber: result.woNumber,
        alreadyExisted: result.alreadyExisted,
      },
    };
  } catch (err) {
    log.error({ err, ctx }, 'Failed to create work order');
    return {
      success: false,
      error: err instanceof Error ? err.message : String(err),
    };
  }
}

/**
 * Create a transfer order from a triggered kanban card.
 *
 * Delegates to the kanban-transfer-automation service which handles:
 * - Validating card state (triggered, active, no duplicate link)
 * - Validating loop (transfer type, has sourceFacilityId)
 * - Creating draft TO + TO line + transitioning card → ordered
 * - Publishing events (automation.to_created, order.created)
 * - Idempotent: returns existing link if card already has a TO
 */
async function handleCreateTransferOrder(
  ctx: TransferOrderContext,
): Promise<ActionHandlerResult> {
  try {
    const result = await autoCreateTransferOrder({
      tenantId: ctx.tenantId,
      cardId: ctx.cardId,
    });

    log.info(
      { toId: result.transferOrderId, toNumber: result.toNumber },
      'Transfer order created by automation',
    );

    return {
      success: true,
      data: {
        transferOrderId: result.transferOrderId,
        toNumber: result.toNumber,
        cardId: result.cardId,
        loopId: result.loopId,
      },
    };
  } catch (err) {
    log.error({ err, ctx }, 'Failed to create transfer order');
    return {
      success: false,
      error: err instanceof Error ? err.message : String(err),
    };
  }
}

/**
 * Dispatch an email to a supplier.
 *
 * Note: Actual email sending is handled by the notifications service.
 * This handler publishes an event that the notifications service picks up.
 */
async function handleDispatchEmail(
  ctx: EmailDispatchContext,
): Promise<ActionHandlerResult> {
  try {
    const eventBus = getEventBus(config.REDIS_URL);
    await eventBus.publish({
      type: 'automation.email_dispatched',
      tenantId: ctx.tenantId,
      purchaseOrderId: ctx.poId,
      supplierId: ctx.supplierId,
      supplierEmail: ctx.supplierEmail,
      totalAmount: ctx.totalAmount,
      source: 'automation',
      timestamp: new Date().toISOString(),
    });

    log.info(
      { poId: ctx.poId, supplierEmail: ctx.supplierEmail },
      'Email dispatch event published',
    );

    return {
      success: true,
      data: { poId: ctx.poId, emailSent: true },
    };
  } catch (err) {
    log.error({ err, ctx }, 'Failed to dispatch email');
    return {
      success: false,
      error: err instanceof Error ? err.message : String(err),
    };
  }
}

/**
 * Add an item to the tenant's shopping list.
 *
 * Publishes an event for the catalog/items service to handle.
 */
async function handleAddToShoppingList(
  params: Record<string, unknown>,
): Promise<ActionHandlerResult> {
  try {
    const eventBus = getEventBus(config.REDIS_URL);
    await eventBus.publish({
      type: 'automation.shopping_list_item_added',
      tenantId: params.tenantId as string,
      partId: params.partId as string,
      quantity: params.quantity as number,
      source: 'automation',
      timestamp: new Date().toISOString(),
    });

    log.info({ params }, 'Shopping list item added by automation');

    return { success: true, data: { added: true } };
  } catch (err) {
    log.error({ err, params }, 'Failed to add to shopping list');
    return {
      success: false,
      error: err instanceof Error ? err.message : String(err),
    };
  }
}

/**
 * Transition a kanban card to a new stage.
 */
async function handleTransitionCard(
  ctx: CardTransitionContext,
): Promise<ActionHandlerResult> {
  try {
    const now = new Date();

    await db
      .update(kanbanCards)
      .set({
        currentStage: ctx.toStage as (typeof kanbanCards.currentStage.enumValues)[number],
        currentStageEnteredAt: now,
        updatedAt: now,
      })
      .where(
        and(
          eq(kanbanCards.id, ctx.cardId),
          eq(kanbanCards.tenantId, ctx.tenantId),
        ),
      )
      .execute();

    // Emit event
    const eventBus = getEventBus(config.REDIS_URL);
    await eventBus.publish({
      type: 'automation.card_stage_changed',
      tenantId: ctx.tenantId,
      cardId: ctx.cardId,
      loopId: ctx.loopId,
      fromStage: ctx.fromStage,
      toStage: ctx.toStage,
      cycleNumber: ctx.cycleNumber,
      source: 'automation',
      timestamp: new Date().toISOString(),
    });

    log.info(
      { cardId: ctx.cardId, fromStage: ctx.fromStage, toStage: ctx.toStage },
      'Card transitioned by automation',
    );

    return {
      success: true,
      data: {
        cardId: ctx.cardId,
        fromStage: ctx.fromStage,
        toStage: ctx.toStage,
      },
    };
  } catch (err) {
    log.error({ err, ctx }, 'Failed to transition card');
    return {
      success: false,
      error: err instanceof Error ? err.message : String(err),
    };
  }
}

/**
 * Resolve an exception by delegating to the exception automation service.
 */
async function handleResolveException(
  ctx: ExceptionResolutionContext,
): Promise<ActionHandlerResult> {
  try {
    const result = await processExceptionAutomation(
      ctx.tenantId,
      ctx.exceptionId,
    );

    log.info(
      { exceptionId: ctx.exceptionId, action: result.action, success: result.success },
      'Exception resolved by automation',
    );

    return {
      success: result.success,
      data: {
        exceptionId: ctx.exceptionId,
        action: result.action,
        detail: result.detail,
      },
    };
  } catch (err) {
    log.error({ err, ctx }, 'Failed to resolve exception');
    return {
      success: false,
      error: err instanceof Error ? err.message : String(err),
    };
  }
}

/**
 * Escalate an action that requires manual intervention.
 *
 * Publishes an escalation event and creates an audit log entry.
 */
async function handleEscalate(
  params: Record<string, unknown>,
): Promise<ActionHandlerResult> {
  try {
    const tenantId = params.tenantId as string;
    const reason = (params.reason as string) ?? 'Automation escalation';

    // Audit log entry — system-initiated escalation
    await writeAuditEntry(db, {
      tenantId,
      userId: null,
      action: 'automation.decision_logged',
      entityType: (params.entityType as string) ?? 'automation',
      entityId: (params.entityId as string) ?? undefined,
      previousState: null,
      newState: { reason, escalated: true },
      metadata: {
        systemActor: 'automation_orchestrator',
        source: 'automation',
        context: params,
      },
    });

    // Emit event
    const eventBus = getEventBus(config.REDIS_URL);
    await eventBus.publish({
      type: 'automation.escalated',
      tenantId,
      reason,
      entityType: (params.entityType as string) ?? 'automation',
      entityId: (params.entityId as string) ?? 'unknown',
      source: 'automation',
      timestamp: new Date().toISOString(),
    });

    log.warn({ tenantId, reason }, 'Action escalated');

    return { success: true, data: { escalated: true, reason } };
  } catch (err) {
    log.error({ err, params }, 'Failed to escalate');
    return {
      success: false,
      error: err instanceof Error ? err.message : String(err),
    };
  }
}
