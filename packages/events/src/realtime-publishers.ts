/**
 * @arda/events — Realtime event publishers
 *
 * Helpers for publishing kpi.refreshed, audit.created, and user.activity
 * events with proper EventMeta and correlation ID propagation.
 */

import { createLogger } from '@arda/config';
import type {
  EventMeta,
  KpiRefreshedEvent,
  AuditCreatedEvent,
  UserActivityEvent,
} from './index.js';
import { getEventBus } from './index.js';

const log = createLogger('events:realtime-publishers');

// ─── EventMeta Builder ─────────────────────────────────────────────

/**
 * Build an EventMeta object with source and correlation ID.
 *
 * Uses the provided correlationId (from x-correlation-id header) or
 * falls back to 'unknown'. Always includes the source service name.
 */
export function buildEventMeta(source: string, correlationId?: string): EventMeta {
  return {
    id: '', // Will be generated by EventBus.publish() if empty
    schemaVersion: 1,
    source,
    correlationId,
    timestamp: new Date().toISOString(),
  };
}

// ─── KPI Refreshed ─────────────────────────────────────────────────

/**
 * KPI metrics affected by different mutation types.
 * Maps mutation domains to the KPI keys they invalidate.
 */
export const KPI_AFFECTED_METRICS: Record<string, string[]> = {
  'purchase_order.created': ['fill_rate', 'order_accuracy'],
  'purchase_order.status_changed': ['fill_rate', 'supplier_otd', 'order_accuracy'],
  'work_order.created': ['avg_cycle_time'],
  'work_order.status_changed': ['avg_cycle_time'],
  'work_order.production_reported': ['avg_cycle_time', 'order_accuracy'],
  'transfer_order.created': ['supplier_otd'],
  'transfer_order.status_changed': ['supplier_otd'],
  'receiving.completed': ['fill_rate', 'supplier_otd', 'order_accuracy'],
  'inventory.adjusted': ['stockout_count'],
  'card.transition': ['stockout_count', 'avg_cycle_time'],
};

export interface PublishKpiRefreshedInput {
  tenantId: string;
  mutationType: string;
  facilityId?: string;
  source: string;
  correlationId?: string;
}

/**
 * Publish kpi.refreshed events for each metric affected by a mutation.
 *
 * Non-critical: failures are logged but do not propagate.
 */
export async function publishKpiRefreshed(input: PublishKpiRefreshedInput): Promise<void> {
  const affectedMetrics = KPI_AFFECTED_METRICS[input.mutationType];
  if (!affectedMetrics || affectedMetrics.length === 0) return;

  try {
    const eventBus = getEventBus();
    const meta = buildEventMeta(input.source, input.correlationId);
    const now = new Date().toISOString();

    await Promise.all(
      affectedMetrics.map((kpiKey) =>
        eventBus.publish(
          {
            type: 'kpi.refreshed',
            tenantId: input.tenantId,
            kpiKey,
            window: '30d',
            facilityId: input.facilityId,
            value: 0,      // Signal to re-fetch; actual value computed on read
            refreshedAt: now,
            timestamp: now,
          } satisfies KpiRefreshedEvent,
          meta,
        ),
      ),
    );
  } catch (err) {
    log.error({ err, mutationType: input.mutationType }, 'Failed to publish kpi.refreshed');
  }
}

// ─── Audit Created ─────────────────────────────────────────────────

export interface PublishAuditCreatedInput {
  tenantId: string;
  auditId: string;
  action: string;
  entityType: string;
  entityId: string | null;
  actorUserId?: string | null;
  method?: 'manual' | 'system' | 'scan' | 'api';
  source: string;
  correlationId?: string;
}

/**
 * Publish an audit.created event after a successful audit log write.
 *
 * Non-critical: failures are logged but do not propagate.
 */
export async function publishAuditCreated(input: PublishAuditCreatedInput): Promise<void> {
  try {
    const eventBus = getEventBus();
    const meta = buildEventMeta(input.source, input.correlationId);

    await eventBus.publish(
      {
        type: 'audit.created',
        tenantId: input.tenantId,
        auditId: input.auditId,
        action: input.action,
        entityType: input.entityType,
        entityId: input.entityId,
        actorUserId: input.actorUserId,
        method: input.method,
        timestamp: new Date().toISOString(),
      } satisfies AuditCreatedEvent,
      meta,
    );
  } catch (err) {
    log.error({ err, action: input.action }, 'Failed to publish audit.created');
  }
}

// ─── User Activity ─────────────────────────────────────────────────

export interface PublishUserActivityInput {
  tenantId: string;
  userId: string;
  activityType: UserActivityEvent['activityType'];
  route?: string;
  resourceType?: string;
  resourceId?: string;
  source: string;
  correlationId?: string;
}

/**
 * Publish a user.activity event for significant authenticated actions.
 *
 * Non-critical: failures are logged but do not propagate.
 */
export async function publishUserActivity(input: PublishUserActivityInput): Promise<void> {
  try {
    const eventBus = getEventBus();
    const meta = buildEventMeta(input.source, input.correlationId);

    await eventBus.publish(
      {
        type: 'user.activity',
        tenantId: input.tenantId,
        userId: input.userId,
        activityType: input.activityType,
        route: input.route,
        resourceType: input.resourceType,
        resourceId: input.resourceId,
        correlationId: input.correlationId,
        timestamp: new Date().toISOString(),
      } satisfies UserActivityEvent,
      meta,
    );
  } catch (err) {
    log.error({ err, activityType: input.activityType }, 'Failed to publish user.activity');
  }
}

// ─── Audit Event Auto-Publishing Setup ────────────────────────────

/**
 * Wire up automatic audit.created event publishing.
 *
 * Call once at service startup AFTER initializing the EventBus.
 * Registers a callback with @arda/db's onAuditWritten hook so that
 * every successful writeAuditEntry call publishes an audit.created event.
 *
 * Uses getCorrelationId() from @arda/observability to propagate the
 * request correlation ID into the event envelope.
 *
 * @param serviceName - The service publishing the event (e.g. 'orders')
 * @param onAuditWrittenFn - The onAuditWritten function from @arda/db
 * @param getCorrelationIdFn - The getCorrelationId function from @arda/observability
 */
export function setupAuditEventPublishing(
  serviceName: string,
  onAuditWrittenFn: (cb: (entry: { tenantId: string; userId?: string | null; action: string; entityType: string; entityId?: string | null }, result: { id: string }) => void) => void,
  getCorrelationIdFn: () => string,
): void {
  onAuditWrittenFn((entry, result) => {
    const correlationId = getCorrelationIdFn();
    // Fire-and-forget — publishAuditCreated is already try/catch wrapped
    void publishAuditCreated({
      tenantId: entry.tenantId,
      auditId: result.id,
      action: entry.action,
      entityType: entry.entityType,
      entityId: entry.entityId ?? null,
      actorUserId: entry.userId,
      method: 'api',
      source: serviceName,
      correlationId: correlationId !== 'unknown' ? correlationId : undefined,
    });
  });
}
